from Compiler import library as lib, oram, path_oram
from Compiler.dijkstra import HeapQ
from Compiler.path_oblivious_heap import (
    PathObliviousHeap,
    POHToHeapQAdapter,
    POHVariant,
    path_oblivious_sort,
)
from Compiler.types import Array, sint

DEBUG = True

from Compiler import path_oblivious_heap

path_oblivious_heap.DEBUG = False


def noop(*args, **kwargs):
    pass


# Only print if DEBUG is enabled
dprint = lib.print_ln if DEBUG else noop

# Benchmark types
INSERT = True
EXTRACT = True
SORTING = False

INSERT = INSERT or EXTRACT  # Always insert if we are going to extract

# Benchmark parameters
## Insert / ExtractMin
RANGE = [2**i for i in range(1, 10)]
OPERATIONS_PER_STEP = 3
TIME_INIT = True
TREE_HEAP = True
TREE_PATH_HEAP = True
LINEAR_HEAP = True
OPTIMAL_TREE_HEAP = False
OPTIMAL_PATH_HEAP = False
POH_PATH = True
POH_PATH_CONSTANT_STASH = True

## Sorting
LENGTHS = [5, 10, 15, 20, 25, 30]

# Timing with consecutive ids

timer_offset = 1000  # Hopefully run timers in an unused range


def start_fancy_timer(id: int | None = None) -> int:
    global timer_offset
    _id = id if id is not None else timer_offset
    lib.start_timer(_id)
    if id is None:
        timer_offset += 1
    return _id


def stop_fancy_timer(id):
    lib.stop_timer(id)


# BENCHMARK

if INSERT:

    def operation_round(q, apply_op, capacity, tag=""):
        global timer_offset
        dprint(f"\n[{tag}] Initializing empty structure with capacity {capacity}")
        id = None
        dprint(f"\n[{tag}] Running updates for capacity {capacity}")
        id = timer_offset  # Handle id manually to avoid incrementing for each operation
        for i in range(OPERATIONS_PER_STEP):
            dprint(f"\n[{tag}] Update {i} for capacity {capacity}")
            start_fancy_timer(id)
            apply_op(q, i)
            stop_fancy_timer(id)
        timer_offset += 1

    def benchmark_operations(q_init, capacity, *args, tag="", **kwargs):
        apply_insert = lambda q, i: q.update(0, i)
        apply_extract = lambda q, _: q.pop()
        if TIME_INIT:
            id = start_fancy_timer()
        q = q_init(capacity, *args, **kwargs)
        if TIME_INIT:
            stop_fancy_timer(id)
        if INSERT:
            operation_round(q, apply_insert, capacity, tag=tag + " insert")
            if EXTRACT:
                operation_round(q, apply_extract, capacity, tag=tag + " extract_min")

    dprint(f"\n\nBENCHMARKING INSERT {'AND EXTRACT ' if EXTRACT else ''}TIME")
    for capacity in RANGE:

        dprint(f"\nCAPACITY {capacity}")

        if TREE_HEAP:
            # Benchmark binary heap built on ORAM (Tree ORAM variant)
            benchmark_operations(
                HeapQ,
                capacity,
                oram_type=oram.RecursiveORAM,
                tag="ORAM Heap (Tree)",
            )

        if TREE_PATH_HEAP:
            # Benchmark binary heap built on ORAM (Path ORAM variant)
            benchmark_operations(
                HeapQ,
                capacity,
                oram_type=path_oram.RecursivePathORAM,
                tag="ORAM Heap (Path)",
            )

        if LINEAR_HEAP:
            # Benchmark binary heap built on ORAM (Linear ORAM variant)
            benchmark_operations(
                HeapQ,
                capacity,
                oram_type=oram.LinearORAM,
                tag="ORAM Heap (Linear)",
            )

        if OPTIMAL_TREE_HEAP:
            # Benchmark binary heap built on ORAM (OptimalORAM variant)
            benchmark_operations(
                HeapQ,
                capacity,
                oram_type=oram.OptimalORAM,
                tag="ORAM Heap (Optimal Tree)",
            )

        if OPTIMAL_PATH_HEAP:
            # Benchmark binary heap built on ORAM (OptimalORAM Path variant)
            benchmark_operations(
                HeapQ,
                capacity,
                oram_type=path_oram.OptimalORAM,
                tag="ORAM Heap (Optimal Path)",
            )

        if POH_PATH:
            # Benchmark Path Oblivious Heap (Path variant)
            benchmark_operations(
                POHToHeapQAdapter,
                capacity,
                bucket_size=2,
                variant=POHVariant.PATH,
                tag="POH (Path)",
            )

        if POH_PATH_CONSTANT_STASH:
            # Benchmark Path Oblivious Heap (Path variant with constant stash size)
            benchmark_operations(
                POHToHeapQAdapter,
                capacity,
                bucket_size=2,
                stash_size=20, # based on empirical analysis by Keller and Scholl
                variant=POHVariant.PATH,
                tag="POH (Path (constant stash size))",
            )

if SORTING:
    dprint("\n\nBENCHMARKING SORTING TIME")
    for n in LENGTHS:
        a = Array(n, sint)
        b = Array(n, sint)

        @lib.for_range(n)
        def _(i):
            a[i] = 2**4 + sint.get_random_int(5)
            b[i] = 2**4 + sint.get_random_int(5)

        lib.print_ln("[Sorting (Radix)] Unsorted array of length %s: %s", n, b.reveal())
        lib.print_ln("[Sorting (Radix)] Sorting array...")
        id = start_fancy_timer()
        b.sort()
        stop_fancy_timer(id)
        lib.print_ln("[Sorting (Radix)] Sorted array: %s", b.reveal())

        lib.print_ln("[Sorting (POH)] Unsorted array of length %s: %s", n, a.reveal())
        lib.print_ln("[Sorting (POH)] Sorting array...")
        id = start_fancy_timer()
        path_oblivious_sort(a, a)
        stop_fancy_timer(id)
        lib.print_ln("[Sorting (POH)] Sorted array: %s", a.reveal())
