from Compiler.path_oblivious_heap import (
    PathObliviousHeap,
    POHToHeapQAdapter,
    test_SubtreeMinEntry_cmp,
)

from Compiler import library as lib
from Compiler.path_oram import OptimalORAM
from Compiler import dijkstra
from Compiler.types import sint

### SETUP ###

# Which tests are we running?
BASIC = True
UNIT = False
DIJKSTRA = True

# Module settings
from Compiler import oram, path_oblivious_heap

oram.crash_on_overflow = False
path_oblivious_heap.CRASH_ON_EMPTY = True
path_oblivious_heap.TRACE = False
path_oblivious_heap.DEBUG = True

### UTILITY ###

# Timing with consecutive ids

timer_offset = 1000  # Hopefully run timers in an unused range


def start_fancy_timer(id: int | None = None) -> int:
    global timer_offset
    _id = id if id is not None else timer_offset
    lib.start_timer(_id)
    if id is None:
        timer_offset += 1
    return _id


def stop_fancy_timer(id):
    lib.stop_timer(id)


### BASIC TEST ###

if BASIC:
    q = dijkstra.HeapQ(2048)
    q.update(sint(0), 0)

    q = PathObliviousHeap(1)
    lib.print_ln(
        "tree depth: %s, stash length: %s, bucket length: %s",
        q.tree.D,
        len(q.tree.stash.ram),
        q.tree.bucket_size,
    )
    q.insert(120, 0)
    q.insert(120, 0)
    q.extract_min()
    q.extract_min()  # Crashes if both entries get same leaf label

if UNIT:
    id = start_fancy_timer()
    test_SubtreeMinEntry_cmp()
    stop_fancy_timer(id)

if DIJKSTRA:
    # ### DIJKSTRA ###

    dijkstra.HeapQ = POHToHeapQAdapter

    # 1 -> 2: 10

    # output should be the following
    # from 0 to 0 at cost 0 via vertex 0
    # from 0 to 1 at cost 5 via vertex 0
    # from 0 to 2 at cost 15 via vertex 1

    # structure for edges
    # contains tuples of form (neighbor, cost, last neighbor bit)
    edges = OptimalORAM(
        4,  # number of edges
        entry_size=(
            2,  # enough bits for vertices
            5,  # enough bits for costs
            1,
        ),  # always one
    )

    # first edge from vertex 0
    edges[0] = (1, 5, 0)
    # second and last edge from vertex 0
    edges[1] = (2, 20, 1)
    # edge from vertex 1
    edges[2] = (2, 10, 1)
    # dummy edge from vertex 2 to itself
    edges[3] = (2, 0, 1)

    # structure assigning edge list indices to vertices
    e_index = OptimalORAM(
        3, entry_size=2  # number vertices
    )  # enough bits for edge indices

    # edges from 0 start at 0
    e_index[0] = 0
    # edges from 1 start at 2
    e_index[1] = 2
    # edges from 2 start at 3
    e_index[2] = 3

    source = sint(0)

    res = dijkstra.dijkstra(source, edges, e_index, OptimalORAM)

    @lib.for_range(res.size)
    def _(i):
        lib.print_ln(
            "from %s to %s at cost %s via vertex %s",
            source.reveal(),
            i,
            res[i][0].reveal(),
            res[i][1].reveal(),
        )
